\documentclass[letterpaper,10pt]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{geometry}
\geometry{textheight=8.5in, textwidth=6in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\newcommand{\toc}{\tableofcontents}

%\usepackage{hyperref}

\def\name{Colin Bradford, Bryce Holley}

%pull in the necessary preamble matter for pygments output
%\input{pygments.tex}

%% The following metadata will show up in the PDF properties
% \hypersetup{
%   colorlinks = false,
%   urlcolor = black,
%   pdfauthor = {\name},
%   pdfkeywords = {cs311 ``operating systems'' files filesystem I/O},
%   pdftitle = {CS 311 Project 1: UNIX File I/O},
%   pdfsubject = {CS 311 Project 1},
%   pdfpagemode = UseNone
% }

\parindent = 0.0 in
\parskip = 0.1 in

\begin{document}
\section{Lab 2}
In the homework, you were asked to write an assembly routine that checks for palindromes in odd length strings. For this portion of the lab, please write a simple C program that does the same thing, use the web based compiler and compile your C code to ARM assembly (use arm-linux-gnueabi-g++-4.6 with option -O0). Compare this assembly with what you wrote. Modify the optimization level from 0 to one of the values in the set {1,2,3,s}. What changes? Why do you think these changes were made?

For this lab, you will need to create a write-up discussing the differences you see in Part 2. Do you see any interesting features being used? Is the hand assembly you wrote significantly different than what the compiler produced? Which uses fewer instructions? In other words, provide an analysis of Part 2.

The compiled assembly code is much larger than our hand-written assembly program. The compiled version uses tons of literals. Part of the reason can be attributed to the fact that our program written in C uses the printf() function in the main() funciton. However, even considering this, the basic function is still larger than our own. The compiled version makes use of the stack frequently, compared to our program. 

Changing the optimization level usually changes the placement of labels. In addition, it seems that with each higher level of optimization, the code is smaller. Based on their optimization, their code might be more effecient that ours due to possibly having less micro-operations.
%input the pygmentized output of mt19937ar.c, using a (hopefully) unique name
%this file only exists at compile time. Feel free to change that.
%\input{__mt19937ar.c.tex}
\end{document}