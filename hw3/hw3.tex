\documentclass[letterpaper,10pt,titlepage]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{listings}

\usepackage{geometry}
\geometry{textheight=8.5in, textwidth=6in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

\def\name{Colin Bradford, Bryce Holley}

%pull in the necessary preamble matter for pygments output
%\input{pygments.tex}

%% The following metadata will show up in the PDF properties
%\hypersetup{
%  colorlinks = true,
%  urlcolor = black,
%  pdfauthor = {\name},
%  pdfkeywords = {cs311 ``operating systems'' files filesystem I/O},
%  pdftitle = {CS 311 Project 1: UNIX File I/O},
%  pdfsubject = {CS 311 Project 1},
%  pdfpagemode = UseNone
%}

\begin{document}
\begin{description}
    \item[3.1] Why is the program counter a pointer and not a counter?
    
    The Program Counter (PC) points to the address of the next instruction to run. This allows the PC to jump to new sections of instructions easily, as compared to a counter.
    \item[3.2] Explain the function of the following registers in a CPU:
    \begin{enumerate}
        \item PC
        
        Answer
        \item MAR
        
        Answer
        \item MBR
        
        Answer
        \item IR
        
        Answer
    \end{enumerate}
    \item[3.3] For each of the following 6-bit operations, calculate the values of the C, Z, V, and N flags.
    \begin{enumerate}
        \item 001011 $+$ 001101 $=$ 011000
        \begin{description}
            \item[C] $=$ 0
            \item[Z] $=$ 0
            \item[V] $=$ 0
            \item[N] $=$ 0
        \end{description}
        \item 111111 $+$ 000001 $=$ 1|000000
        \begin{description}
            \item[C] $=$ 1
            \item[Z] $=$ 1
            \item[V] $=$ 0
            \item[N] $=$ 0
        \end{description}
        \item 000000 $-$ 111111 $=>$ 000000 $+$ 000001 $=$ 000001 
        \begin{description}
            \item[C] $=$ 0
            \item[Z] $=$ 0
            \item[V] $=$ 0
            \item[N] $=$ 0
        \end{description}
        \item 101101 $+$ 011011 $=$ 1|001000
        \begin{description}
            \item[C] $=$ 1
            \item[Z] $=$ 0
            \item[V] $=$ 0
            \item[N] $=$ 0
        \end{description}
        \item 000000 $-$ 000001 $=>$ 000000 $+$ 111111 $=$ 111111
        \begin{description}
            \item[C] $=$ 0
            \item[Z] $=$ 0
            \item[V] $=$ 0
            \item[N] $=$ 1
        \end{description}
        \item 111110 $+$ 111111 $=$ 1|111101
        \begin{description}
            \item[C] $=$ 1
            \item[Z] $=$ 0
            \item[V] $=$ 0
            \item[N] $=$ 1
        \end{description}
    \end{enumerate}
    \item[3.10] Why does the ARM provide a reverse subtract instruction RSB ro,r1,r2 that implements $[r0] = [r2] - [r1]$ when the normal subtraction instruction SUB r0,r2,r1 will do exactly the same job?
    
    Answer
    \item[3.17] ARM instructions have a $12-bit$ literal. Instead of permitting a word in the range 0 to $2^(12) - 1$, the ARM uses an $8-bit$ format for the integer and a $4-bit$ alignment field that allows the integer to be shifted in steps of 2. What are the advantages and disadvantages of this mechanism in comparison with a straight $12-bit$ integer?
    
    A straight $12-bit$ integer provides the maximum precision of $12-bits$, but only has values in the range of $2^(12) - 1$. The $4-bit$ alignment field allows a precision of $8-bits$, but allows a larger range of values as you multiply the value by a maximum of $2^(2^5 - 1)$.
    \item[3.18] Write one or more ARM instructions that will clear bits 20 to 25 inclusive in register r0. All the other bits of r0 should remain unchanged.
    
    Answer
    \item[3.19] This is a class problem of assembly language programming. Write a sequence of ARM instructions that swap the contents of register r0 and r1 without using any additional registers or memory storage (that is, you can't move r1 to a temporary location).
    
    \lstinputlisting[language={[x86masm]Assembler}, firstline=15, lastline=17]{p3_19.s}
    \item[3.25] What is the binary encoding of the following instructions?
    \begin{enumerate}
        \item STRB r1,[r2]
        
        Answer
        \item LDR r3,[r4,r5] !
        
        Answer
        \item LDR r3,[r4],r5
        
        Answer
        \item LDR r3,[r4,\#-6] !
        
        Answer
    \end{enumerate}
    \item[3.39] Write an ARM assembly language program that scans a string terminated by the null byte $0x00$ and copies the string from a source location pointed at by r0 to a destination pointed at by r1.
    
    Answer
    \item[3.51] Write an ARM assembly language program to determine whether a string of characters with an odd length is a palindrome (for example, mom) under the following constraints.
    \begin{enumerate}
        \item The string of ASIC-encoded characters is stored in memory.
        \item At the start of the program, register r1 contains the address of the first character in the string, and r2 contains the address of the las character. On exit from the program, register r0 contains a 0 if the string is not a palindrome, and 1 if it is.
    \end{enumerate}
    
    Answer
\end{description}

%input the pygmentized output of mt19937ar.c, using a (hopefully) unique name
%this file only exists at compile time. Feel free to change that.
%\input{__mt19937ar.c.tex}
\end{document}