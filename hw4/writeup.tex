\documentclass[letterpaper,10pt,titlepage]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{listings}

\usepackage{geometry}
\geometry{textheight=8.5in, textwidth=6in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

\def\name{Colin Bradford, Bryce Holley}

%pull in the necessary preamble matter for pygments output
%\input{pygments.tex}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs472 ``computer architecture'' ISA assembly},
  pdftitle = {CS 472 Homework 4},
  pdfsubject = {CS 472 Homework 4},
  pdfpagemode = UseNone,
}

\begin{document}
\title{Homework 4}
\author{\name}
\date{\today}
\maketitle
\begin{description}
    \item[3.8] What are the relative advantages and disadvantages of general-purpose registers compared to separate address and data registers?
    
    Separating registers into address and data registers allow instructions to assume more depending on the type of register used in an instruction. A general-purpose register would require more insight as to how it should be treated. Assuming one system had the same number of general-purpose registers as another system had data and address registers combined, then the one with general-purpose registers could hold more addresses or data values in their registers at a time than could the latter.
    \item[3.9] What is a misaligned operand? Why are misaligned operands such a problem in programming?
    
    Answer
    \item[3.24] What is the meaning of each of the P, U, B, W, and L bits in the encoding of an ARM memory reference instruction?
    \begin{description}
        \item[P] Pointer adjust (Pre/Post$-$increment). 0 $=$ point-index operation: use pointer then adjust. 1 $=$ pre-index operation: adjust pointer then use pointer. TL;DR: determines when to adjust the pointer (before or after using the value of the pointer).
        \item[U] Pointer direction (Up/Down). 0 $=$ decrement pointer. 1 $=$ increment pointer. TL;DR: Determines how to adjust the pointer (increment or decrement).
        \item[B] Operand size (Byte/Word). 0 $=$ word access. 1 $=$ byte access. TL;DR: determines how much data should be transfered.
        \item[W] Pointer update (Write-back). 0 $=$ don't write back adjusted pointer. 1 $=$ write back adjusted pointer. TL;DR: determines if the pointer should be changed.
        \item[L] Data direction (Load/store). 0 $=$ store in memory. 1 $=$ load into register. TL;DR: determines if data should flow from register to data memory, or from data memory to the register.
    \end{description}
    \item[3.26] What is the effect of LDR r0, [r5,r6, LSL r2]?
    
    Load r0 with the value at the address contained in (r5, incremented by the value in (r6, logically shifted left by (the value in r2) bits)).
    \item[3.30] What is the meaning of sign-extension in the context of copying data from one location to another?
    
    Sign extention is extending leading 0s or 1s for a positive or negative value, respectively. Sign extention can be an issue when moving from a smaller container to a larger one. A value that is initially negative, when moved into a larger container with leading 0s, will appear positive (incorrectly).
    \item[3.33] Most RISC processors do not include a block move instruction. What are the advantages and disadvantages of the ARM's LDM and STM instructions?
    
    Advantages: Move many values in one command; easy interface with stack; save/restore registers for subroutines;\\
    Disadvantages: There are many options/variations, so implementation can be difficult;
    \item[3.34] What is the effect of executing STMIB r13!, {r0-r2, r4}? Draw a picture of the states of the stack pointed at by r13 before and after this operation.
    
    The values of r0, r1, r2, and r4 will be stored in r13+1, r13+2, r13+3, and r13+4 respectively (i.e. [r13+1] = [r0], [r13+2] = [r1], [r13+3] = [r2], [r13+4] = [r4]). In addition, r13 will be set to r13+4 after it completes the previous function. Basically, the instruction pushes r0-r2 and r4 onto the stack in that order. 
    
    \begin{lstlisting}
    Stack before:
             Address    Contents
             ________    ________
            | beg + 1|  |whatever|
    r13 ->  |  beg   |  |whatever|
            |  ...   |  |  ...   |
            |   0    |  |whatever|
            |________|  |________|
    
    Stack after:
             Address    Contents
             ________    ________
            | beg+6  |  |whatever|
    r13 ->  | beg+5  |  |whocares|
            | beg+4  |  |  [r4]  |
            | beg+3  |  |  [r2]  |
            | beg+2  |  |  [r1]  |
            | beg+1  |  |  [r0]  |
            | beg    |  |whatever|
            |  ...   |  |  ...   |
            |   0    |  |whatever|
            |________|  |________|
    \end{lstlisting}
    \item[3.36] Without using the ARM's multiplication instruction, write on or more instruction (using ADD, SUB, and shifting) to multiply the following integers.
    \begin{description}
        \item[a.] 33
        
        \begin{lstlisting}
        MOV r0, #5 ;arbitrary multiplicand\\
	ADD r0, r0, r0, LSL #5 ;shifting left 5 is r0*32, add r0 for 33.
    \end{lstlisting}
        \item[b.] 1025
        
        \begin{lstlisting}
        MOV r0, #5 ;arbitrary multiplicand\\
	ADD r0, r0, r0, LSL #10 ;shifting left 10 is r0*1024, add r0 for 1025.
    \end{lstlisting}
        \item[c.] 4095
        
        \begin{lstlisting}
        MOV r1, #5 ;arbitrary multiplicand\\
	MOV r0, #0 ;clear r0\\
	ADD r0, r0, r1, LSL #12 ;shifting left 12 is r0*4096.
	SUB r0, r0, r1 ;subtract r1 from the result for 4095.
    \end{lstlisting}
    \end{description}
    \item[3.44] What does the following code do?
    \begin{lstlisting}
        TEQ     r0, #0
        RSBMI   r0, r0, #0
    \end{lstlisting}
    
    \begin{lstlisting}
    if (r0 != #0) { negate r0 }
    \end{lstlisting}
    \item[3.48] What, in the context of assembly language, is a pseudoinstruction?
    
    A pseudoinstruction is not an actual instruction in the ISA, but rather a composition of actual instructions of the ISA defined as the pseudoinstruction; it's like a function that consists of instructions.
    \item[3.54] Explain what this fragment of code does instruction by instruction and what purpose it achieves (assuming that register r0 is the register of interest). Note that the data in r0 must not be 0 on entry.
    \begin{lstlisting}
            MOV     r1, #0
    loop    MOVS    r0, r0, LSL #1
            ADDCC   r1, r1, #1
            BCC     loop
    \end{lstlisting}
    
    Load r1 with zero\\
    Double r0 (set carry bit if appropriate)\\
    Add 1 to r1 if carry bit is clear\\
    Branch to loop if carry bit is clear\\
    PURPOSE: At end of execution, r1 will hold the number of leading 0s initially in r1.
    \item[3.60] A computer has three eight-element vectors in memory, Va, Vb, and Vc. Each element of a vector is a 32-bit word. Write the code to colculate all the elements of Vc if the ith element is given by $Vc_i = \frac{1}{2}(Va_i + Vb_i)$
    
    \begin{lstlisting}
		ADR r0, D60a		;ptr to Va0
		ADR r1, D60b		;ptr to Vb0
		MOV r2, #0x000000F0	;ptr to Vc0
		MOV r3, #7		;counter
	LOOP	LDR r4, [r0, r3, LSL #2];load r4 with Vai
		LDR r5, [r1, r3, LSL #2];load r5 with Vbi
		ADD r4, r4, r5		;add Vbi to Vai, with carry
		ASR r4, r4, #1		;divide by 2
		STR r4, [r2, r3, LSL #2];store result to Vci
		SUBS r3, #1		;increment counter
		BPL LOOP		;loop until r3 == 0
    \end{lstlisting}
    \item[3.61] Register r15 is the program counter. You can use it with certain instructions such as a MOV (e.g., MOV  pc, r14). However, r15 cannot be used in conjunction with most data processing instructions. Why?
    
    Yo momma.
    %\lstinputlisting[language={[x86masm]Assembler}, firstline=8, lastline=19]{p3_51.s}
\end{description}
\end{document}